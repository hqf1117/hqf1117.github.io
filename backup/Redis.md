memcached只支持字符串类型，不支持持久化，是用多线程加锁实现得。

## 常用得五大数据类型

- String

  String 类型是==二进制安全的==。意味着可以包含任何数据，比如图片或者序列化的对象。最大长度==512M==。

  基本命令：set   get  append  strlen  setnx  incr  decr

  底层为动态字符串

![image-20220721215625603](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/eec98f48-f0e0-4ee7-aa41-7d0518424b8a)


- List

  单键多值。底层实际是一个==双向链表==，对两端的性能很高，中间的节点性能较差。值在键在，值光键亡。

  
![image-20220721220228084](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/0dfaa759-7358-4fbc-8cb9-a3955d759a58)


  常用命令：lpush/rpush lpop/rpop rpoplpush

- Set

  是string类型的无序集合。底层其实是一个value为null的hash表。

- Hash 

  dict字典结构

- Zset

  有序集合

  常用命令：zadd,zcard,zcount

  底层实现：

  - 压缩表

    - 元素数量少于128的时候

    - 每个元素的长度小于64字节

    满足以上两个条件使用压缩表，否则为跳表。

  - 跳表

    跳表最高32层


  
![image-20220529192137281-1658051994404](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/123306d1-790d-4b56-beea-33ea6f74eb21)


## 发布订阅

Redis 发布订阅（pub/sub）是一种消息通信模式。Redis客户端可以订阅任意数量的频道。

## 新数据类型

- Bitmaps

- HyperLogLog

  用于做基数（不重复元素）统计的算法，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的，并且时很小的。

- Geospatial

  二维坐标，在地图上就是经纬坐标。

## Redis事务

redis事务时一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求打断。主要作用是==防止串联的多个命令被插队==。

如果multi组队过程中命令报错则全都不执行，如果exec过程中命令报错则只有报错的命令不执行，其他命令都会执行，不会回滚。

==redis集群不支持事务不支持lua脚本==

### 乐观锁

watch key [key..] 监听某些key,如果事务过程中，值被改变则无法执行成功。

### 事务的三特性

- 单独的隔离操作
- 没有隔离级别的概念
- 不保证原子性

## 管道

## redis持久化

### RDB

在指定的==时间间隔==内将内存中的==数据集快照==写入磁盘，恢复时将快照文件直接读到内存里。

#### 备份如何执行

会单独创建一个fork子进程来进行持久化，会先将数据写入到一个临时文件中，等持久化过程结束后，再用这个临时文件替换上次的文件。==linux写时复制技术==

优点：性能高，节省磁盘空间，恢复快适合大数据量，但完整性不敏感的情况

缺点：

- 最后一次持久化后的数据可能丢失。
- 虽然是写时拷贝技术，但是如果数据庞大时仍消耗性能。
- fork的时候内存中的数据被克隆了一份，需要考虑2倍的膨胀性。

![image-20220726232657500](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/fb63c5a1-180e-4c78-86bd-acb77eb5b1ed)


### AOF append only file

==以日志的形式来记录每个写操作指令（增量保存）==，不记录读操作，==只许追加文件但不可以改写文件==。默认不开启。

#### aof文件损坏

通过redis-check-aof--fix appendonly.aof进行修复。

#### aof频率设置

always:始终同步，每次写入都会立刻写入日志。

everysec:每秒同步。

no:不主动同步，时机交给操作系统决定。

#### rewrite压缩

当aof文件大小超过所设定的阈值时，如阈值为64M,则128M时会触发重写操作，redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集。

## redis架构

### 主从复制

![image-20220727193743568](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/2228c83b-b2d0-4328-9fc0-6061f9f48247)

读写分离以及容灾快速恢复。slave只读，不可写入。

master节点挂了，不会重新选举，通过slaveof no one 手动升为master节点。

slave节点挂了，重启以后会从master节点同步数据，slave节点发送同步请求，master节点持久化rdb文件，并发送给slave节点进行同步。

每次master节点有数据写入，则发送给slave节点进行同步。

缺点：有一定延迟。

#### 传火

slave节点分层挂载在其他slave节点下。master节点通知太多slave节点性能差。

#### 哨兵模式

redis-sentinel 启动哨兵节点。

哨兵如何选举新的master节点：

1. 选择优先级靠前的，replica-priority 配置属性 最小的；
2. 选择偏移量最大的，就是跟master节点数据最接近的；
3. 选择runid最小的，每次实例启动会随机生成一个40位的runid；

选出新的master节点后，sentinel向其他slave节点发送slaveof命令改变从属关系；

重启后的旧master节点，sentinel会向其发送slaveof命令将其变为slave节点。

### 集群模式

无中心化集群。任何一个节点都可以是入口，节点内部再进行转发。

集群模式下某个master节点宕机后，slave节点会升级成master节点==15秒超时==。

cluster-require-full-coverage yes 某一组主从节点都挂掉后，整个集群都会挂掉。

不支持lua脚本。

#### slots插槽

一个redis集群包含16384个插槽，CRC16(key)%16384来计算key属于哪个插槽。

#### HashTag

set key{hashTag} value 用来使得一组值被分配到同一个节点上。 

## 分布式锁

### redisson

分段分布式锁提升并发性能。

底层为redis hash 类型，hash属性为**当前锁的uuid:线程id**，value值为重入次数。

### 红锁

由于redis主从或者集群架构的情况下，主从同步需要时间，可能存在master节点在同步完成之前宕机的可能性，所以需要红锁。

<img width="1091" alt="image-20220923205015958" src="https://github.com/hqf1117/hqf1117.github.io/assets/30412361/558c9888-22ab-40fd-9efd-681d93f460f4">

## Redis6新特性

- acl权限

- IO多线程

  **网络io多线程，执行命令单线程**。

## Redis的过期和内存淘汰

### 过期策略

1. **定期删除**

   定期删除类似一个守护线程,每间隔一段时间就执行一次（默认100ms一次,可以通过修改配置文件redis.conf 的 hz选项来调整这个次数）,将过期的Key进行删除,具体过程如下:

   - 从过期字典中随机选出20个key;
   - 删除这20个key中已经过期的key;
   - 如果过期的key的比例超过了1/4,那就重复从步骤1开始执行;

   优点：不用每次扫描全部过期的key，节省cpu资源。

   缺点：会遗漏很多过期的key。

2. **惰性删除**

   惰性删除即当查询某个Key时，判断该key是否已过期，如果已过期则从缓存中删除，同时返回空。

### 内存淘汰

早期版本的 `Redis` 有以下 6 种淘汰策略：

1. **noeviction**：不淘汰任何数据，当内存不足时，新增操作会报错，`Redis` **默认内存淘汰策略**；
2. **allkeys-lru**：淘汰整个键值中最久未使用的键值；
3. **allkeys-random**：随机淘汰任意键值;
4. **volatile-lru**：淘汰所有设置了过期时间的键值中最久未使用的键值；
5. **volatile-random**：随机淘汰设置了过期时间的任意键值；
6. **volatile-ttl**：优先淘汰更早过期的键值。

在 `Redis 4.0` 版本中又新增了 2 种淘汰策略：

1. **volatile-lfu**：淘汰所有设置了过期时间的键值中，最少使用的键值；
2. **allkeys-lfu**：淘汰整个键值中最少使用的键值。

#### 修改 Redis 内存淘汰策略

- 方式一：通过 `config set maxmemory-policy 策略` 命令设置。它的优点是设置之后立即生效，不需要重启 `Redis` 服务，缺点是重启 `Redis` 之后，设置就会失效。
- 方式二：通过修改 `Redis` 配置文件修改，设置 `maxmemory-policy 策略`，它的优点是重启 `Redis` 服务后配置不会丢失，缺点是必须重启 `Redis` 服务，设置才能生效。

#### 内存淘汰算法

- LRU：`LRU` 算法需要基于链表结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可。

  实际上redis的实现：近似LRU

  它的实现方式是给现有的数据结构添加一个额外的字段，用于记录此键值的**最后一次访问时间**，24bit存储，`Redis` 内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后**淘汰最久没有使用的那个。**

  缺点：非热点key可能由于刚被访问过而没有被淘汰

- LFU：它的核心思想是**如果数据过去被访问多次，那么将来被访问的频率也更高**。

​		在 `Redis` 中 `LFU` 存储分为两部分，16 bit 的 `ldt`（`last decrement time`）和 8 bit 的 `logc`（`logistic counter`）。与`LRU`一样一共是24bit。

​		`logc` 是用来存储访问频次，8 bit 能表示的最大整数值为 255，它的值越小表示使用频率越低，越容易淘汰；

​	    `ldt` 是用来存储上一次 `logc` 的更新时间，16bit能表示的最大值为65535（65535/24/60≈45.5），大概45.5天会折返（折返指的是取模后的值重新从0开始）。

​		相关配置，如下：

​		`lfu-log-factor`可以调整计数器`counter`的增长速度，`lfu-log-factor`越大，`counter`增长的越慢。

​		`lfu-decay-time`是一个以分钟为单位的数值，可以调整`counter`的减少速度

## **缓存击穿**

缓存只是为了缓解数据库压力而添加的一层保护层，当从缓存中查询不到我们需要的数据就要去数据库中查询了。如果被黑客利用，频繁去访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库连接异常。

解决方案：

1、后台设置定时任务，主动的去更新缓存数据。这种方案容易理解，但是当key比较分散的时候，操作起来还是比较复杂的

2、分级缓存。比如设置两层缓存保护层，1级缓存失效时间短，2级缓存失效时间长。有请求过来优先从1级缓存中去查找，如果在1级缓存中没有找到相应数据，则对该线程进行加锁，这个线程再从数据库中取到数据，更新至1级和2级缓存。其他线程则直接从2级线程中获取

3、提供一个拦截机制，内部维护一系列合法的key值。当请求的key不合法时，直接返回。

- 对空值缓存
- 设置白名单
- 布隆过滤器：不支持删除元素，需要定期重建来保持低误判率。
- 实时监控：当发现redis的命中率开始急速降低，则运维上线解决问题。

## **缓存雪崩**

缓存雪崩就是指缓存由于某些原因（比如 宕机、cache服务挂了或者不响应）整体crash掉了，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难，也就是上面提到的缓存击穿。

![v2-44c3673c78e1f56cbf7261c987876427_720w](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/1a029c23-d362-4acc-974e-1578fbdb6af1)

如何避免雪崩：

1、给缓存加上一定区间内的随机生效时间，不同的key设置不同的失效时间，避免同一时间集体失效。

2、和缓存击穿解决方案类似，做二级缓存，原始缓存失效时从拷贝缓存中读取数据。

3、利用加锁或者队列方式避免过多请求同时对服务器进行读写操作。

