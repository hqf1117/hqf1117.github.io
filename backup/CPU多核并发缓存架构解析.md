## cpu缓存架构图

![image-20220517203818178](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/9cccbc17-f6fa-4ccc-85bf-1b55e47051b8)
![image-20220517204033606](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/2b37633f-0511-48dd-884b-d60d7ac2d2e6)
![image-20220517204502377](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/b8dd8954-df7f-46e2-9ed4-64b4440d6062)
![image-20220517204928094](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/e2d48838-9b79-490b-86c0-462327416813)



​		由于，工作内存的载入是以64kB为单位的，所以可能会连带载入不需要的缓存数据，此时可能发生其他CPU的线程修改这部分数据时，会发生频繁的失效刷新机制，影响cpu执行性能，这种情况叫==伪共享==。可以考虑采用==@Contented==注解来实现内存填充，避免这个问题。但是也可能会导致内存消耗变大影响性能，最好是能从设计上进行==内存对齐==。

![image-20220517205457632](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/1e60c230-3d00-4c37-aab8-a835ed6da661)


### happens-before 的8条原则：

1. 次序规则：1个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；
2. 锁定规则： 1个unlock操作先行发生于后面（时间上的先后）对同一个锁的lock操作；
3. volatile变量规则： 对一个volatile变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：a先于b,b先于c,则a先于c;
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；
6. 线程中断检测规则：
   - 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生；
   - 可以通过Thread.interrupted()检测到是否发生中断；
   - 必要要先调用interrupt()方法设置过中断标志位，才能检测到中断发生。
7. 线程终止规则 ：线程中的所有操作都先行发生于对此线程的终止检测，可以通过isAlive()等手段检测线程是否已经终止执行。
8. 对象终结规则：一个对象初始化完成先行发生于finalize()方法的开始

### volatile内存屏障

是CPU或编译器在队内存随机访问的操作中的一个同步点。使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。

实际上是JVM指令，volatile无法保证原子性。

分类：

- 读屏障：在读指令之前插入读屏障，让工作内存或CPU告诉缓存中的缓存数据失效，重新回到主内存中获取最新数据。
  - LoadLoad:
  - LoadStore:
- 写屏障：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。
  - StoreLoad:
  - StoreStore:

![image-20220704213124639](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/fd713100-5d79-45bc-b7f7-f2b5f0378b29)

![image-20220704213151950](https://github.com/hqf1117/hqf1117.github.io/assets/30412361/018d7d56-7b15-4b1a-b4b5-7e83bf43d172)

#### 适用场景

- 单一赋值，但不包含复合运算赋值(i++)之类；
- 状态标志，判断业务是否结束；
- 开销较低的读，读多写少的情况下，volatile修饰并且加写锁；
- DCL双端锁的发布；